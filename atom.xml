<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://938650141.github.io</id>
    <title>独木舟游四海</title>
    <updated>2020-09-20T00:38:47.887Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://938650141.github.io"/>
    <link rel="self" href="https://938650141.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://938650141.github.io/images/avatar.png</logo>
    <icon>https://938650141.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 独木舟游四海</rights>
    <entry>
        <title type="html"><![CDATA[[LeetCode双周赛]第35场双周赛]]></title>
        <id>https://938650141.github.io/post/leetcode-shuang-zhou-sai-di-35-chang-shuang-zhou-sai/</id>
        <link href="https://938650141.github.io/post/leetcode-shuang-zhou-sai-di-35-chang-shuang-zhou-sai/">
        </link>
        <updated>2020-09-20T00:21:09.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<ol start="5503">
<li>所有奇数长度子数组的和<br>
给你一个正整数数组 arr ，请你计算所有可能的奇数长度子数组的和。<br>
子数组 定义为原数组中的一个连续子序列。<br>
请你返回 arr 中 所有奇数长度子数组的和 。</li>
</ol>
</blockquote>
<p>只需循环左端点的基础上循环右端点并维护左端点为起点右端点为重点的区间和，判断区间长度为奇书则加入到答案中。</p>
<pre><code>class Solution {
public:
    int sumOddLengthSubarrays(vector&lt;int&gt;&amp; arr) {
        int ans=0;
        for(int i=0;i&lt;arr.size();i++){
            int sum=0;
            for(int j=i;j&lt;arr.size();j++){
                sum+=arr[j];
                if((j-i)%2==0) ans+=sum;
            }
        }
        return ans;
    }
};
</code></pre>
<blockquote>
<ol start="5505">
<li>所有排列中的最大和<br>
有一个整数数组 nums ，和一个查询数组 requests ，其中 requests[i] = [start<sub>i</sub>, end<sub>i</sub>] 。第 i 个查询求 nums[start<sub>i</sub>] + nums[start<sub>i</sub> + 1] + ... + nums[end<sub>i</sub> - 1] + nums[end<sub>i</sub>] 的结果 ，start<sub>i</sub> 和 end<sub>i</sub> 数组索引都是 从 0 开始 的。<br>
你可以任意排列 nums 中的数字，请你返回所有查询结果之和的最大值。<br>
由于答案可能会很大，请你将它对 109 + 7 取余 后返回。</li>
</ol>
</blockquote>
<p>实际上是每次选取多个nums里的某个区间进行求和，如果从单个元素的贡献来看，如果某个位置被覆盖的次数最多，如果想要答案最大，则这个元素是nums里最大的数字。根据这个思路只需要统计每个位置被覆盖的次数，然后排序被统计的次数，再排序nums，这两者相同位置相乘求和即可。</p>
<pre><code>class Solution {
public:
    long long a[100005];
    int maxSumRangeQuery(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; requests) {
        long long ans=0;
        int mod=(int)1e9+7;
        for(int i=0;i&lt;requests.size();i++) a[requests[i][0]+1]++,a[requests[i][1]+2]--;
        int n=nums.size();
        for(int i=1;i&lt;=n;i++) a[i]+=a[i-1];
        vector&lt;long long&gt;v;
        sort(nums.begin(),nums.end());
        for(int i=1;i&lt;=n;i++) v.push_back(a[i]);
        sort(v.begin(),v.end());
        for(int i=0;i&lt;n;i++) ans=(ans+v[i]*(nums[i]))%mod;
        return ans;
    }
};
</code></pre>
<blockquote>
<ol start="5504">
<li>使数组和能被 P 整除<br>
给你一个正整数数组 nums，请你移除 最短 子数组（可以为 空），使得剩余元素的 和 能被 p 整除。 不允许 将整个数组都移除。<br>
请你返回你需要移除的最短子数组，如果无法满足题目要求，返回 -1 。<br>
子数组 定义为原数组中连续的一组元素。</li>
</ol>
</blockquote>
<p>如果要让数组和能被P整除，反过来就是找一段子区间的和是(数组和%p)</p>
<pre><code>class Solution {
public:
    unordered_map&lt;int,int&gt;mp;
    long long sum[100005];
    int minSubarray(vector&lt;int&gt;&amp; nums, int p) {
        long long a=0;
        for(int i=0;i&lt;nums.size();i++) sum[i+1]=nums[i],a+=nums[i];
        a%=p;
        if(a==0) return 0;
        int n=nums.size();
        int ans=0x3f3f3f3f;
        mp[0]=0;
        for(int i=1;i&lt;=n;i++){
            sum[i]+=sum[i-1];
            sum[i]%=p;
            if(mp.find((sum[i]-a+p)%p)!=mp.end()){
                ans=min(ans,i-mp[(sum[i]-a+p)%p]);
            }
            mp[sum[i]]=i;
        }
        return ((ans==0x3f3f3f3f)||(ans==n))?-1:ans;
    }
};
</code></pre>
<blockquote>
<ol start="5506">
<li>奇怪的打印机 II<br>
给你一个奇怪的打印机，它有如下两个特殊的打印规则：<br>
每一次操作时，打印机会用同一种颜色打印一个矩形的形状，每次打印会覆盖矩形对应格子里原本的颜色。<br>
一旦矩形根据上面的规则使用了一种颜色，那么 相同的颜色不能再被使用 。<br>
给你一个初始没有颜色的 m x n 的矩形 targetGrid ，其中 targetGrid[row][col] 是位置 (row, col) 的颜色。<br>
如果你能按照上述规则打印出矩形 targetGrid ，请你返回 true ，否则返回 false 。</li>
</ol>
</blockquote>
<p>我的想法是每次找到一个矩形，然后将其全部变成通用颜色，直到找不到为止，如果最后全部方块都是通用颜色则说明true否则false。</p>
<pre><code>class Solution {
public:
    int mnh[100],mxh[100],mnl[100],mxl[100];
    int pic[105][105];
    int vis[105];
    bool isPrintable(vector&lt;vector&lt;int&gt;&gt;&amp; targetGrid) {
        for(int i=1;i&lt;=60;i++) mnh[i]=0x3f3f3f3f,mnl[i]=0x3f3f3f3f;
        for(int i=1;i&lt;=60;i++) mxh[i]=0xcfcfcfcf,mxl[i]=0xcfcfcfcf;
        for(int i=0;i&lt;targetGrid.size();i++){
            for(int j=0;j&lt;targetGrid[i].size();j++){
                int now=targetGrid[i][j];
                mnh[now]=min(mnh[now],i+1);
                mxh[now]=max(mxh[now],i+1);
                mnl[now]=min(mnl[now],j+1);
                mxl[now]=max(mxl[now],j+1);
                pic[i+1][j+1]=targetGrid[i][j];
            }
        }
        bool flag=true;
        while(flag){
            flag=false;
            for(int i=1;i&lt;=60;i++){
                bool isSq=true;
                if(mxh[i]-mnh[i]&lt;0 || mxl[i]-mnl[i]&lt;0) isSq=false;
                for(int j=mnh[i];j&lt;=mxh[i];j++){
                    for(int k=mnl[i];k&lt;=mxl[i];k++){
                        if(pic[j][k]!=i &amp;&amp; pic[j][k]!=100 ) isSq=false;
                    }
                }
                if(isSq){
                    flag=true;
                    for(int j=mnh[i];j&lt;=mxh[i];j++){
                        for(int k=mnl[i];k&lt;=mxl[i];k++){
                            pic[j][k]=100;
                        }
                    }
                    mnh[i]=0x3f3f3f3f,mnl[i]=0x3f3f3f3f;
                    mxh[i]=0xcfcfcfcf,mxl[i]=0xcfcfcfcf;
                }
            }
        }
        int n=(int)targetGrid.size();
        int m=(int)targetGrid[0].size();
        bool ok=true;
        for(int i=1;i&lt;=n;i++)
            for(int j=1;j&lt;=m;j++)
                if(pic[i][j]!=100) ok=false;
        return ok;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[HackerRank]Absolute Permutation题解]]></title>
        <id>https://938650141.github.io/post/hackerrankabsolute-permutation-ti-jie/</id>
        <link href="https://938650141.github.io/post/hackerrankabsolute-permutation-ti-jie/">
        </link>
        <updated>2020-09-19T14:03:39.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>给定n和k询问是否存在一个长度为n的不重复数组与从1到n的序列相同位置一一对应元素的绝对值均为k</p>
</blockquote>
<p>本题目参考GeeksforGeeks题解*<br>
当k为0是显然只需要输出从1到n的序列即可<br>
更进一步的观察可以相当，n一定是2k的倍数，这样才能满足i和i+k元素的互换，这样i位置是i+k，i+k位置是i，满足了题目的要求。<br>
于是只需要判断好是否满足条件直接模拟一下输出答案即可</p>
<pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

vector&lt;string&gt; split_string(string);

// Complete the absolutePermutation function below.
vector&lt;int&gt; absolutePermutation(int n, int k) {
    vector&lt;int&gt;ans;
    if(k==0){
        for(int i=1;i&lt;=n;i++) ans.push_back(i);
        return ans;
    }
    if(n%(k*2)!=0){
        ans.push_back(-1);
        return ans;
    }
    else{
        for(int i=1;i&lt;=n;i++){
            if(((i-1)/k)%2==0) ans.push_back(i+k);
            else ans.push_back(i-k);
        }
        return ans;
    }
    return ans;
}

int main()
{
    ofstream fout(getenv(&quot;OUTPUT_PATH&quot;));

    int t;
    cin &gt;&gt; t;
    cin.ignore(numeric_limits&lt;streamsize&gt;::max(), '\n');

    for (int t_itr = 0; t_itr &lt; t; t_itr++) {
        string nk_temp;
        getline(cin, nk_temp);

        vector&lt;string&gt; nk = split_string(nk_temp);

        int n = stoi(nk[0]);

        int k = stoi(nk[1]);

        vector&lt;int&gt; result = absolutePermutation(n, k);

        for (int i = 0; i &lt; result.size(); i++) {
            fout &lt;&lt; result[i];

            if (i != result.size() - 1) {
                fout &lt;&lt; &quot; &quot;;
            }
        }

        fout &lt;&lt; &quot;\n&quot;;
    }

    fout.close();

    return 0;
}

vector&lt;string&gt; split_string(string input_string) {
    string::iterator new_end = unique(input_string.begin(), input_string.end(), [] (const char &amp;x, const char &amp;y) {
        return x == y and x == ' ';
    });

    input_string.erase(new_end, input_string.end());

    while (input_string[input_string.length() - 1] == ' ') {
        input_string.pop_back();
    }

    vector&lt;string&gt; splits;
    char delimiter = ' ';

    size_t i = 0;
    size_t pos = input_string.find(delimiter);

    while (pos != string::npos) {
        splits.push_back(input_string.substr(i, pos - i));

        i = pos + 1;
        pos = input_string.find(delimiter, i);
    }

    splits.push_back(input_string.substr(i, min(pos, input_string.length()) - i + 1));

    return splits;
}

</code></pre>
<hr>
<p>*https://www.geeksforgeeks.org/k-difference-permutation/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[LeetCode每日刷题]2020.09.19]]></title>
        <id>https://938650141.github.io/post/leetcode-mei-ri-shua-ti-20200919/</id>
        <link href="https://938650141.github.io/post/leetcode-mei-ri-shua-ti-20200919/">
        </link>
        <updated>2020-09-19T02:35:45.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>No.404 左叶子之和<br>
计算给定二叉树的所有左叶子之和。</p>
</blockquote>
<p>递归一遍，如果左右儿子不存在且当前结点是父亲节点的左儿子就加上当前结点的数字，最后返回答案即可。</p>
<pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int ans=0;
    void dfs(TreeNode* o,int w){
        if(o-&gt;left==nullptr &amp;&amp; o-&gt;right==nullptr){
            if(w==1) ans+=o-&gt;val;
        }else{
            if(o-&gt;left!=nullptr) dfs(o-&gt;left,1);
            if(o-&gt;right!=nullptr) dfs(o-&gt;right,0);
        }
    }
    int sumOfLeftLeaves(TreeNode* root) {
        if(root==nullptr) return 0;
        dfs(root,-1);
        return ans;
    }
};
</code></pre>
<blockquote>
<p>No.2 两数相加<br>
给定两个链表代表两个数，求两个数求和后的链表</p>
</blockquote>
<pre><code>/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummyHead = new ListNode(0);
        ListNode p=l1,q=l2,cur=dummyHead;
        int carry=0;
        while(p!=null || q!=null){
            int x=(p!=null)?p.val:0;
            int y=(q!=null)?q.val:0;
            int sum=carry+x+y;
            carry=sum/10;
            cur.next=new ListNode(sum%10);
            cur=cur.next;
            if(p!=null) p=p.next;
            if(q!=null) q=q.next;
        }
        if(carry!=0) cur.next=new ListNode(carry);
        return dummyHead.next;
    }
}
</code></pre>
<blockquote>
<p>No.150 逆波兰表达式求值</p>
</blockquote>
<p>栈的应用</p>
<pre><code>class Solution {
    public int evalRPN(String[] tokens) {
        Stack&lt;Integer&gt; s=new Stack&lt;&gt;();
        Integer a,b;
        for(int i=0;i&lt;tokens.length;i++){
            if(tokens[i].equals(&quot;+&quot;)){
                a=s.pop();
                b=s.pop();
                s.push(a+b);
            }else if(tokens[i].equals(&quot;-&quot;)){
                a=s.pop();
                b=s.pop();
                s.push(b-a);
            }else if(tokens[i].equals(&quot;*&quot;)){
                a=s.pop();
                b=s.pop();
                s.push(a*b);
            }else if(tokens[i].equals(&quot;/&quot;)){
                a=s.pop();
                b=s.pop();
                s.push(b/a);
            }else{
                s.push(Integer.valueOf(tokens[i]));
            }
        }
        return s.pop();
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[HackerRank]Reverse Shuffle Merge题解]]></title>
        <id>https://938650141.github.io/post/hackerrankreverse-shuffle-merge-ti-jie/</id>
        <link href="https://938650141.github.io/post/hackerrankreverse-shuffle-merge-ti-jie/">
        </link>
        <updated>2020-09-19T02:21:36.000Z</updated>
        <content type="html"><![CDATA[<p>给定一个字符串的翻转字符串和乱序字符串，然后按照两个字符串的顺序不变的情况下进行合并得到一个合并字符串。<br>
询问合并字符串中字典序最小的原字符串。<br>
根据题意原字符串中的每个字符必定在给定的合并字符串中出现两次。<br>
所以统计合并字符串中每个字符的出现次数，最后将每个字符的出现次数/2就是原字符串中所有的字符。<br>
但问题在于如何确定最小字典序原字符串字符的顺序。<br>
我的解决策略是通过二分每次找到最小的合法的位置能使其左侧字符均包含当前需要的所有字符，然后只需要从小到大字符的队列，将其合法右侧的字符位置出队，判断需要当前字符，当前字符的最大位置是否在合法区间中，如果找到就进行下一次的二分合法区间，找寻下一个字符。</p>
<pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

// Complete the reverseShuffleMerge function below.
int cnt[26];
int sum[10005][26];
queue&lt;int&gt;q[26];
bool check(int x){
    for(int i=0;i&lt;26;i++) if(sum[x][i]&lt;cnt[i]) return false;
    return true;
}
string reverseShuffleMerge(string s) {
    for(int i=0;i&lt;(int)s.size();i++){
        cnt[s[i]-'a']++;
        sum[i][s[i]-'a']++;
        for(int j=0;j&lt;26;j++) if(i!=0) sum[i][j]+=sum[i-1][j];
    }
    for(int i=(int)s.size()-1;i&gt;=0;i--) q[s[i]-'a'].push(i);
    for(int i=0;i&lt;26;i++) cnt[i]/=2;
    string ans;
    int a=(int)s.size()/2;
    int last=s.size()-1;
    while(a--){
        int l=0,r=last,pos=r;
        while(l&lt;=r){
            int m=(l+r)/2;
            if(check(m)) pos=m,r=m-1;
            else l=m+1;
        }
        for(int i=0;i&lt;26;i++){
            while(q[i].size() &amp;&amp; q[i].front()&gt;last) q[i].pop();
            if(cnt[i]&gt;0 &amp;&amp; q[i].size() &amp;&amp; q[i].front()&gt;=pos) {
                ans+=(char)('a'+i);
                cnt[i]--;
                last=q[i].front()-1;
                break;
            }
        }
    }
    return ans;
}

int main()
{
    string s;
    cin&gt;&gt;s;
    cout&lt;&lt;reverseShuffleMerge(s);
    return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[LeetCode每日刷题]2020.09.18]]></title>
        <id>https://938650141.github.io/post/leetcode-mei-ri-shua-ti-20200918/</id>
        <link href="https://938650141.github.io/post/leetcode-mei-ri-shua-ti-20200918/">
        </link>
        <updated>2020-09-17T23:44:03.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>No.47 全排列 II<br>
给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
</blockquote>
<p>排序后用next_permutation()函数即可</p>
<pre><code>class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) {
        vector&lt;vector&lt;int&gt;&gt;ans;
        sort(nums.begin(),nums.end());
        do{
            ans.push_back(nums);
        }while(next_permutation(nums.begin(),nums.end()));
        return ans;
    }
};
</code></pre>
<blockquote>
<p>No.5 最长回文子串<br>
给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
</blockquote>
<p>dp[i][j]表示i起始j终止的子串是否是回文串<br>
当j-i=0表示i到j只有一个字符显然是回文串<br>
当j-i=1表示i到j只有两个字符只需检查这两个字符是否是回文子串<br>
其余的情况在检查第i个字符和第j个字符是否相同的基础上（首尾字符相同），看一看去掉这两个字符是否是回文子串</p>
<pre><code>class Solution {
    public String longestPalindrome(String s) {
        int n=s.length();
        boolean[][] dp=new boolean[n][n];
        String ans=&quot;&quot;;
        for(int l=0;l&lt;n;l++){
            for(int i=0;i+l&lt;n;i++){
                int j=i+l;
                if(l==0) dp[i][j]=true;
                else if(l==1) dp[i][j]=(s.charAt(i)==s.charAt(j));
                else dp[i][j]=(s.charAt(i)==s.charAt(j) &amp;&amp; dp[i+1][j-1]);
                if(dp[i][j] &amp;&amp; l+1&gt;ans.length()){
                    ans=s.substring(i,i+l+1);
                }
            }
        }
        return ans;
    }
}
</code></pre>
<blockquote>
<p>No.31 下一个排列<br>
实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。<br>
如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
</blockquote>
<p>也是使用next_permutation()</p>
<pre><code>class Solution {
public:
    void nextPermutation(vector&lt;int&gt;&amp; nums) {
        if(!next_permutation(nums.begin(),nums.end())) sort(nums.begin(),nums.end());
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[LeetCode每日刷题]2020.09.17]]></title>
        <id>https://938650141.github.io/post/leetcode-mei-ri-shua-ti-20200917/</id>
        <link href="https://938650141.github.io/post/leetcode-mei-ri-shua-ti-20200917/">
        </link>
        <updated>2020-09-17T14:08:47.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>No.15 三数之和<br>
给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。<br>
注意：答案中不可以包含重复的三元组。</p>
</blockquote>
<p>（参考LeetCode题解）<br>
首先进行排序，然后用双指针求解，这种方法能够<strong>去除重复解</strong><br>
复杂度O(NlogN)</p>
<p>代码：</p>
<pre><code>class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {
        sort(nums.begin(),nums.end());
        vector&lt;vector&lt;int&gt;&gt;ans;
        if(nums.size()&lt;3) return ans;
        for(int i=0;i&lt;nums.size();i++){
            if(nums[i]&gt;0) return ans;
            if(i&gt;0 &amp;&amp; nums[i]==nums[i-1]) continue;
            int l=i+1,r=nums.size()-1;
            while(l&lt;r){
                if(nums[i]+nums[l]+nums[r]==0){
                    ans.push_back(vector&lt;int&gt;({nums[i],nums[l],nums[r]}));
                    while(l&lt;r &amp;&amp; nums[l]==nums[l+1]) l++;
                    while(l&lt;r &amp;&amp; nums[r]==nums[r-1]) r--;
                    l++,r--;
                }else{
                    if(nums[i]+nums[l]+nums[r]&gt;0) r--;
                    else l++;
                }
            }
        }
        return ans;
    }
};
</code></pre>
<blockquote>
<p>No.11 盛最多水的容器<br>
给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
</blockquote>
<p>双指针分别在左右端点，每次的解是min(a[l],a[r])*(r-l)，可以考虑到当左右端点移动时，底长会变小，而使答案变大的唯一可能是选择移动的端点是高度会变高的点<br>
复杂度O(N)</p>
<pre><code>class Solution {
public:
    int maxArea(vector&lt;int&gt;&amp; height) {
        int l=0,r=height.size()-1;
        int ans=0;
        while(l&lt;=r){
            ans=max(ans,min(height[l],height[r])*(r-l));
            if(height[l]&gt;height[r]) r--;
            else l++;
        }
        return ans;
    }
};
</code></pre>
<blockquote>
<p>No.685 冗余连接 II<br>
在本问题中，有根树指满足以下条件的有向图。该树只有一个根节点，所有其他节点都是该根节点的后继。每一个节点只有一个父节点，除了根节点没有父节点。<br>
输入一个有向图，该图由一个有着N个节点 (节点值不重复1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。<br>
结果图是一个以边组成的二维数组。 每一个边 的元素是一对 [u, v]，用以表示有向图中连接顶点 u 和顶点 v 的边，其中 u 是 v 的一个父节点。<br>
返回一条能删除的边，使得剩下的图是有N个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。</p>
</blockquote>
<p>最多1000个顶点，也就是最多1000条边，每次从后到前选择一个边进行删除，检查删除后的图是否符合无环且所有端点连通形成有根树<br>
复杂度O(N^2)</p>
<pre><code>class Solution {
public:
    int fa[1005];
    int cnt[1005];
    int get(int x){
        if(x==fa[x]) return x;
        return fa[x]=get(fa[x]);
    }
    void merge(int x,int y){
        fa[get(x)]=get(y);
    }
    bool check(int x,vector&lt;vector&lt;int&gt;&gt;&amp; edges){
        for(int i=1;i&lt;=1000;i++) fa[i]=i,cnt[i]=0;
        for(int i=0;i&lt;edges.size();i++){
            if(i!=x){
                if(get(edges[i][0])==get(edges[i][1])) return false;
                merge(edges[i][0],edges[i][1]);
                cnt[edges[i][1]]++;
            }
        }
        for(int i=1;i&lt;=edges.size();i++) if(cnt[i]&gt;1) return false;
        int nowr=get(1);
        int ans=0;
        for(int i=1;i&lt;=edges.size();i++) if(get(i)==nowr) ans++;
        return ans==(int)edges.size();
    }
    vector&lt;int&gt; findRedundantDirectedConnection(vector&lt;vector&lt;int&gt;&gt;&amp; edges) {
        for(int i=edges.size()-1;i&gt;=0;i--){
            if(check(i,edges)) return edges[i];
        }
        vector&lt;int&gt;ans;
        return ans;
    }
};
</code></pre>
]]></content>
    </entry>
</feed>