<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://938650141.github.io</id>
    <title>独木舟游四海</title>
    <updated>2020-12-03T10:59:07.346Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://938650141.github.io"/>
    <link rel="self" href="https://938650141.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://938650141.github.io/images/avatar.png</logo>
    <icon>https://938650141.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 独木舟游四海</rights>
    <entry>
        <title type="html"><![CDATA[ZOJ4114]]></title>
        <id>https://938650141.github.io/post/zoj4114/</id>
        <link href="https://938650141.github.io/post/zoj4114/">
        </link>
        <updated>2020-12-02T14:40:39.000Z</updated>
        <content type="html"><![CDATA[<p>n个开关，k轮，每轮m次按下不同开关<br>
询问从初始状态到终态的方案数</p>
<p>只需要确定初始有k个和终态不同的开关数<br>
之后直接转移即可<br>
dp[i][j]代表第i轮有j个开关与终态不同</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

const int mod=(int)998244353;

int qpow(int a,int b){
	a%=mod;
	int ans=1;
	while(b){
		if(b&amp;1) ans=((long long)ans*a)%mod;
		a=((long long)a*a)%mod;
		b&gt;&gt;=1;
	}
	return ans;
}

int fec[1005];
int inv[1005];
string s1,s2;
int n,m,k;
long long dp[205][205];

int C(int a,int b){
	return ((long long)fec[a]*inv[b]%mod)*inv[a-b]%mod;
}

int main(){
	fec[0]=1;
	inv[0]=1;
	for(int i=1;i&lt;=1000;i++) fec[i]=((long long)fec[i-1]*i)%mod;
	for(int i=1;i&lt;=1000;i++) inv[i]=qpow(fec[i],mod-2);
	int t;
	cin&gt;&gt;t;
	while(t--){
		cin&gt;&gt;n&gt;&gt;k&gt;&gt;m;
		cin&gt;&gt;s1&gt;&gt;s2;
		memset(dp,0,sizeof(dp));
		int cnt=0;
		for(int i=0;i&lt;n;i++) cnt+=(s1[i]!=s2[i]);
		dp[0][cnt]=1;
		for(int i=0;i&lt;k;i++){
			for(int j=0;j&lt;=n;j++){
				for(int k=0;k&lt;=m;k++){
					if(j&gt;=k &amp;&amp; n-j&gt;=m-k)
						dp[i+1][j-k+m-k]+=((long long)(dp[i][j]*C(j,k)%mod)*C(n-j,m-k))%mod,dp[i+1][j-k+m-k]%=mod;
				}
			}
		}
		cout&lt;&lt;dp[k][0]%mod;
		if(t!=0) cout&lt;&lt;&quot;\n&quot;;
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[排列组合]]></title>
        <id>https://938650141.github.io/post/pai-lie-zu-he/</id>
        <link href="https://938650141.github.io/post/pai-lie-zu-he/">
        </link>
        <updated>2020-12-02T04:42:31.000Z</updated>
        <content type="html"><![CDATA[<p>n个物品分给m个人，每人最少分1个<br>
C(n-1,m-1)，n-1个空选出m-1个即可</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

int f[1000005];
int inv[1000005];
const int mod=998244353;

int qpow(int a,int b){
	a%=mod;
	int ans=1;
	while(b){
		if(b&amp;1) ans=((long long)ans*a)%mod;
		b&gt;&gt;=1;
		a=((long long)a*a)%mod;
	}
	return ans;
}

int main(){
	f[0]=1;
	inv[0]=1;
	for(int i=1;i&lt;=1000000;i++) f[i]=((long long)f[i-1]*i)%mod;
	for(int i=1;i&lt;=1000000;i++) inv[i]=qpow(f[i],mod-2);
	int t;
	cin&gt;&gt;t;
	while(t--){
		int n,m;
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		int ans=1;
		ans=((long long)f[n-1]*inv[m-1])%mod;
		ans=((long long)ans*inv[n-m])%mod;
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}
</code></pre>
<p>n个物品分给m个人，允许为空<br>
则人为地填充n个物品，使其满足隔板法要求，再人为地将每个人扣除一个物品，是等价的效果<br>
C(n+m-1,m-1)</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

int f[2000005];
int inv[2000005];
const int mod=998244353;

int qpow(int a,int b){
	a%=mod;
	int ans=1;
	while(b){
		if(b&amp;1) ans=((long long)ans*a)%mod;
		b&gt;&gt;=1;
		a=((long long)a*a)%mod;
	}
	return ans;
}

int main(){
	f[0]=1;
	inv[0]=1;
	for(int i=1;i&lt;=2000000;i++) f[i]=((long long)f[i-1]*i)%mod;
	for(int i=1;i&lt;=2000000;i++) inv[i]=qpow(f[i],mod-2);
	int t;
	cin&gt;&gt;t;
	while(t--){
		int n,m;
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		int ans=1;
		ans=((long long)f[n+m-1]*inv[m-1])%mod;
		ans=((long long)ans*inv[n])%mod;
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}
</code></pre>
<p>n个物品，m个人，分配m个、m+1个……n个物品给m个人的方案数<br>
<img src="https://938650141.github.io/post-images/1606985887150.jpg" alt="主条目：朱世杰恒等式" loading="lazy"></p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

int f[2000005];
int inv[2000005];
const int mod=998244353;

int qpow(int a,int b){
	a%=mod;
	int ans=1;
	while(b){
		if(b&amp;1) ans=((long long)ans*a)%mod;
		b&gt;&gt;=1;
		a=((long long)a*a)%mod;
	}
	return ans;
}

int main(){
	f[0]=1;
	inv[0]=1;
	for(int i=1;i&lt;=2000000;i++) f[i]=((long long)f[i-1]*i)%mod;
	for(int i=1;i&lt;=2000000;i++) inv[i]=qpow(f[i],mod-2);
	int t;
	cin&gt;&gt;t;
	while(t--){
		int n,m;
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		int ans=1;
		ans=((long long)f[n]*inv[m])%mod;
		ans=((long long)ans*inv[n-m])%mod;
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}
</code></pre>
<p>拿出0个或1个或2个……或n个来分给m个人<br>
同样根据上面的式子</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

int f[2000005];
int inv[2000005];
const int mod=998244353;

int qpow(int a,int b){
	a%=mod;
	int ans=1;
	while(b){
		if(b&amp;1) ans=((long long)ans*a)%mod;
		b&gt;&gt;=1;
		a=((long long)a*a)%mod;
	}
	return ans;
}

int main(){
	f[0]=1;
	inv[0]=1;
	for(int i=1;i&lt;=2000000;i++) f[i]=((long long)f[i-1]*i)%mod;
	for(int i=1;i&lt;=2000000;i++) inv[i]=qpow(f[i],mod-2);
	int t;
	cin&gt;&gt;t;
	while(t--){
		int n,m;
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		int ans=1;
		ans=((long long)f[n+m]*inv[m])%mod;
		ans=((long long)ans*inv[n])%mod;
		//ans=(ans-1+mod)%mod;
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}
</code></pre>
<p>n个物品分配给3个人，每个人带限制[1,a+1),[1,b+1),[1,c+1)<br>
利用容斥</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

int f[2000005];
int inv[2000005];
const int mod=998244353;

int qpow(int a,int b){
	a%=mod;
	int ans=1;
	while(b){
		if(b&amp;1) ans=((long long)ans*a)%mod;
		b&gt;&gt;=1;
		a=((long long)a*a)%mod;
	}
	return ans;
}

int C(int a,int b){
	if(b&gt;a) return 0;
	int ans=1;
	ans=((long long)f[a]*inv[b])%mod;
	ans=((long long)ans*inv[a-b])%mod;
	return ans;
}

int main(){
	f[0]=1;
	inv[0]=1;
	for(int i=1;i&lt;=2000000;i++) f[i]=((long long)f[i-1]*i)%mod;
	for(int i=1;i&lt;=2000000;i++) inv[i]=qpow(f[i],mod-2);
	int t;
	cin&gt;&gt;t;
	while(t--){
		int n,a,b,c;
		scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;a,&amp;b,&amp;c);
		int ans=0;
		ans=(ans+C(n-1,2))%mod;
		ans=(ans-C(n-a-1,2))%mod;
		ans=(ans-C(n-b-1,2))%mod;
		ans=(ans-C(n-c-1,2))%mod;
		ans=(ans+C(n-a-b-1,2))%mod;
		ans=(ans+C(n-a-c-1,2))%mod;
		ans=(ans+C(n-b-c-1,2))%mod;
		ans=(ans-C(n-a-b-c-1,2))%mod;
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}
</code></pre>
<p>n个物品分配给3个人，限制[0,a+1),[0,b+1),[0,c+1)</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

int f[2000005];
int inv[2000005];
const int mod=998244353;

int qpow(int a,int b){
	a%=mod;
	int ans=1;
	while(b){
		if(b&amp;1) ans=((long long)ans*a)%mod;
		b&gt;&gt;=1;
		a=((long long)a*a)%mod;
	}
	return ans;
}

int C(int a,int b){
	if(b&gt;a) return 0;
	int ans=1;
	ans=((long long)f[a]*inv[b])%mod;
	ans=((long long)ans*inv[a-b])%mod;
	return ans;
}

int main(){
	f[0]=1;
	inv[0]=1;
	for(int i=1;i&lt;=2000000;i++) f[i]=((long long)f[i-1]*i)%mod;
	for(int i=1;i&lt;=2000000;i++) inv[i]=qpow(f[i],mod-2);
	int t;
	cin&gt;&gt;t;
	while(t--){
		int n,a,b,c;
		scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;a,&amp;b,&amp;c);
		int ans=0;
		ans=(ans+C(n+3-1,2))%mod;
		ans=(ans-C(n-a-1+3-1,2)+mod)%mod;
		ans=(ans-C(n-b-1+3-1,2)+mod)%mod;
		ans=(ans-C(n-c-1+3-1,2)+mod)%mod;
		ans=(ans+C(n-a-1-b-1+3-1,2))%mod;
		ans=(ans+C(n-a-1-c-1+3-1,2))%mod;
		ans=(ans+C(n-b-1-c-1+3-1,2))%mod;
		ans=(ans-C(n-a-1-b-1-c-1+3-1,2)+mod)%mod;
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}
</code></pre>
<p>n个物品，3个人，每次拿出3~n个物品分给每个人，限制限制[1,a+1),[1,b+1),[1,c+1)</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

int f[2000005];
int inv[2000005];
const int mod=998244353;

int qpow(int a,int b){
	a%=mod;
	int ans=1;
	while(b){
		if(b&amp;1) ans=((long long)ans*a)%mod;
		b&gt;&gt;=1;
		a=((long long)a*a)%mod;
	}
	return ans;
}

int C(int a,int b){
	if(b&gt;a) return 0;
	int ans=1;
	ans=((long long)f[a]*inv[b])%mod;
	ans=((long long)ans*inv[a-b])%mod;
	return ans;
}

int main(){
	f[0]=1;
	inv[0]=1;
	for(int i=1;i&lt;=2000000;i++) f[i]=((long long)f[i-1]*i)%mod;
	for(int i=1;i&lt;=2000000;i++) inv[i]=qpow(f[i],mod-2);
	int t;
	cin&gt;&gt;t;
	while(t--){
		int n,a,b,c;
		scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;a,&amp;b,&amp;c);
		int ans=0;
		ans=(ans+C(n,3))%mod;
		ans=(ans-C(n-a,3)+mod)%mod;
		ans=(ans-C(n-b,3)+mod)%mod;
		ans=(ans-C(n-c,3)+mod)%mod;
		ans=(ans+C(n-a-b,3))%mod;
		ans=(ans+C(n-a-c,3))%mod;
		ans=(ans+C(n-b-c,3))%mod;
		ans=(ans-C(n-a-b-c,3)+mod)%mod;
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}
</code></pre>
<p>n个物品，3个人，每次拿出3~n个物品分给每个人，限制限制[0,a+1),[0,b+1),[0,c+1)</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

int f[2000005];
int inv[2000005];
const int mod=998244353;

int qpow(int a,int b){
	a%=mod;
	int ans=1;
	while(b){
		if(b&amp;1) ans=((long long)ans*a)%mod;
		b&gt;&gt;=1;
		a=((long long)a*a)%mod;
	}
	return ans;
}

int C(int a,int b){
	if(b&gt;a) return 0;
	int ans=1;
	ans=((long long)f[a]*inv[b])%mod;
	ans=((long long)ans*inv[a-b])%mod;
	return ans;
}

int main(){
	f[0]=1;
	inv[0]=1;
	for(int i=1;i&lt;=2000000;i++) f[i]=((long long)f[i-1]*i)%mod;
	for(int i=1;i&lt;=2000000;i++) inv[i]=qpow(f[i],mod-2);
	int t;
	cin&gt;&gt;t;
	while(t--){
		int n,a,b,c;
		scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;a,&amp;b,&amp;c);
		int ans=0;
		ans=(ans+C(n+3,3))%mod;
		ans=(ans-C(n-a-1+3,3)+mod)%mod;
		ans=(ans-C(n-b-1+3,3)+mod)%mod;
		ans=(ans-C(n-c-1+3,3)+mod)%mod;
		ans=(ans+C(n-a-1-b-1+3,3))%mod;
		ans=(ans+C(n-a-1-c-1+3,3))%mod;
		ans=(ans+C(n-b-1-c-1+3,3))%mod;
		ans=(ans-C(n-a-1-b-1-c-1+3,3)+mod)%mod;
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mobius函数]]></title>
        <id>https://938650141.github.io/post/mobius-han-shu/</id>
        <link href="https://938650141.github.io/post/mobius-han-shu/">
        </link>
        <updated>2020-11-30T02:44:14.000Z</updated>
        <content type="html"><![CDATA[<pre><code>//Mobius函数求解代码
for(int i=1;i&lt;=n;i++) miu[i]=1,v[i]=0;
    for(int i=2;i&lt;=n;i++){
        if(v[i]) continue;
        miu[i]=-1;
        for(int j=2*i;j&lt;=n;j+=i){
            v[j]=1;
            if((j/i)%i==0) miu[j]=0;
            else miu[j]*=-1;
        }
    }
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://938650141.github.io/post-images/1606704338830.jpg" alt="例题" loading="lazy"></figure>
<pre><code>#include&lt;cstdio&gt;
using namespace std;
const int N=(int)1e6+5;
int n;
int miu[N];
int v[N];

long long f(int x){
    int ans=0;
    while(x){
        ans+=x%10;
        x/=10;
    }
    return ans;
}

long long g(int x){
    int ans=1;
    while(x){
        ans*=x%10;
        x/=10;
    }
    return ans;
}

int main(){
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=1;i&lt;=n;i++) miu[i]=1,v[i]=0;
    for(int i=2;i&lt;=n;i++){
        if(v[i]) continue;
        miu[i]=-1;
        for(int j=2*i;j&lt;=n;j+=i){
            v[j]=1;
            if((j/i)%i==0) miu[j]=0;
            else miu[j]*=-1;
        }
    }
    long long ans=0;
    for(int i=1;i&lt;=n;i++){
        for(int j=i;j&lt;=n;j+=i){
            ans+=(long long)miu[i]*(n/i-j/i+1)*g(j);
            ans+=(long long)miu[i]*(j/i)*f(j);
        }
    }
    printf(&quot;%lld&quot;,ans);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[接口技术复习]]></title>
        <id>https://938650141.github.io/post/jie-kou-ji-zhu-fu-xi/</id>
        <link href="https://938650141.github.io/post/jie-kou-ji-zhu-fu-xi/">
        </link>
        <updated>2020-11-20T13:39:27.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://938650141.github.io/post-images/1605879582952.jpg" alt="" loading="lazy"><br>
<img src="https://938650141.github.io/post-images/1605879587215.jpg" alt="" loading="lazy"><br>
<img src="https://938650141.github.io/post-images/1605879590934.jpg" alt="" loading="lazy"><br>
<img src="https://938650141.github.io/post-images/1605879594166.jpg" alt="" loading="lazy"><br>
<img src="https://938650141.github.io/post-images/1605879597400.jpg" alt="" loading="lazy"><br>
<img src="https://938650141.github.io/post-images/1605879600607.jpg" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Codeforces Round #684 (Div. 2)]]></title>
        <id>https://938650141.github.io/post/codeforces-round-684-div-2/</id>
        <link href="https://938650141.github.io/post/codeforces-round-684-div-2/">
        </link>
        <updated>2020-11-18T12:55:54.000Z</updated>
        <content type="html"><![CDATA[<p>A.</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

int main(){
    int t;
    cin&gt;&gt;t;
    while(t--){
        int n,c0,c1,h;
        string s;
        cin&gt;&gt;n&gt;&gt;c0&gt;&gt;c1&gt;&gt;h&gt;&gt;s;
        int ans=0;
        for(int i=0;i&lt;s.size();i++){
            if(s[i]=='0') ans+=min(c0,c1+h);
            else ans+=min(c1,c0+h);
        }
        cout&lt;&lt;ans&lt;&lt;&quot;\n&quot;;
    }
    return 0;
}
</code></pre>
<p>B.</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
using namespace std;
int a[200005];

int main(){
    int t;
    cin&gt;&gt;t;
    while(t--){
        int n,k;
        cin&gt;&gt;n&gt;&gt;k;
        for(int i=1;i&lt;=n*k;i++){
            scanf(&quot;%d&quot;,&amp;a[i]);
        }
        sort(a+1,a+n*k+1);
        reverse(a+1,a+n*k+1);
        int m=n-(n+1)/2+1;
        long long ans=0;
        for(int i=m,j=1;j&lt;=k;i+=m,j++) ans+=a[i];
        cout&lt;&lt;ans&lt;&lt;&quot;\n&quot;;
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[计算机网络]HTTP学习笔记]]></title>
        <id>https://938650141.github.io/post/ji-suan-ji-wang-luo-http-xue-xi-bi-ji/</id>
        <link href="https://938650141.github.io/post/ji-suan-ji-wang-luo-http-xue-xi-bi-ji/">
        </link>
        <updated>2020-10-31T07:56:15.000Z</updated>
        <content type="html"><![CDATA[<p>每一项技术从无到有，逐渐发展的过程需要用历史的眼光去看待。<br>
最开始的互联网一开始的设想是让远隔两地的人能够相互分享知识，构成WWW，于是有几个最关键的东西就需要确定下来。</p>
<ul>
<li>内容的格式</li>
<li>传输的协议</li>
<li>资源的定位</li>
</ul>
<p>这三个东西我们可以从两个人的邮件互通开始看起，两个人想要写邮件互相交流，那就必须知道对方家庭所在地址，这样邮件才能寄到对方的手中，但是仅此并不够，还需要交给指定的通路去寄邮件。如同邮政快递属于社会基础服务一般，我们现在的网路通信，一样是基础的设施，在基础的设施好之后，我们就规定设施的服务按照某一规则来，这就是协议。但是双方通信还需要一致的交流格式及其语言，否则就可能看不懂，这就需要规定内容的格式。<br>
以上三样基本构成了交流通信的关键。</p>
<p>我们先从传输的协议看起，这是传输信息中最重要的，也可以说一封邮件的传输，失败的可能性最大应在传输的过程中。</p>
<p>这个我们就要从计算机网络的模型开始讨论起，但是过于底层的内容应当放在后面，所以我们先从当今网络最重要的网络协议TCP/IP讲起。</p>
<blockquote>
<p>计算机与网络设备要相互通信，双方就必须基于相同的方法。比如， 如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通 信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之 间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为 协议（protocol）。</p>
</blockquote>
<p>应用层是应用程序层面。<br>
传输层是交付应用程序数据的控制层面。<br>
网络层是在逻辑上划分数据单元并进行传递的结构层面。<br>
链路层是在物理上规定各个结点的硬件是如何进行数据交换的硬件层面。</p>
<p>每一层向下传递则增加首尾部，进行封装。<br>
反之，亦然。</p>
<blockquote>
<p>IP 协议的作用是把各种数据包传送给对方。而要保证确实传送到对方 那里，则需要满足各类条件。其中两个重要的条件是 IP 地址和 MAC 地址（Media Access Control Address）。 IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定 地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC 地址基本上不会更改。</p>
</blockquote>
<blockquote>
<p>使用 ARP 协议凭借 MAC 地址进行通信 IP 间的通信依赖 MAC 地址。在网络上，通信的双方在同一局域网 （LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转 才能连接到对方。而在进行中转时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标。这时，会采用 ARP 协议（Address Resolution Protocol）。ARP 是一种用以解析地址的协议，根据通信方 的 IP 地址就可以反查出对应的 MAC 地址。</p>
</blockquote>
<blockquote>
<p>这种机制称为路由选择（routing），有点像快递公司的送货过程。想 要寄快递的人，只要将自己的货物送到集散中心，就可以知道快递公 司是否肯收件发货，该快递公司的集散中心检查货物的送达地址，明 确下站该送往哪个区域的集散中心。接着，那个区域的集散中心自会 判断是否能送到对方的家中。</p>
</blockquote>
<p>因为IP协议不提供可靠的传输，所以需要TCP来进行控制，确保信息的通信正常。</p>
<blockquote>
<p>TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够 确认数据最终是否送达到对方。</p>
</blockquote>
<p>通过打招呼的方式，A和B的交流通信要从hello开始一样，A询问B，你能听到我说话吗，B回答能，那你能听到我说话吗，A回答能，之后AB可以进行正常的交流了。<br>
在TCP中就是三次握手，通过SYN进行询问，ACK应答确认。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[蓝桥杯]知识梳理]]></title>
        <id>https://938650141.github.io/post/lan-qiao-bei-yi-zhou-bei-zhan-di-shi-yi-jie-lan-qiao-bei-oct11~17/</id>
        <link href="https://938650141.github.io/post/lan-qiao-bei-yi-zhou-bei-zhan-di-shi-yi-jie-lan-qiao-bei-oct11~17/">
        </link>
        <updated>2020-10-11T10:30:12.000Z</updated>
        <content type="html"><![CDATA[<p>① DFS \ BFS =&gt;<br>
② 前缀和<br>
③</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[LeetCode周赛]第207场周赛]]></title>
        <id>https://938650141.github.io/post/leetcode-zhou-sai-di-207-chang-zhou-sai/</id>
        <link href="https://938650141.github.io/post/leetcode-zhou-sai-di-207-chang-zhou-sai/">
        </link>
        <updated>2020-09-20T06:30:30.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/contest/weekly-contest-207/problems/rearrange-spaces-between-words/">5519. 重新排列单词间的空格</a><br>
略</p>
<p><a href="https://leetcode-cn.com/problems/split-a-string-into-the-max-number-of-unique-substrings/">5520. 拆分字符串使唯一子字符串的数目最大</a></p>
<p>优化暴力，暴力循环分割位置的集合，检查是否合法，逆向循环进行优化；</p>
<pre><code>class Solution {
public:
    set&lt;string&gt;mp;
    int maxUniqueSplit(string s) {
        int n=s.size()-1;
        int ans=1;
        for(int i=(1&lt;&lt;n)-1;i&gt;=1;i--){
            int k=0;
            for(int j=0;j&lt;=n+1;j++) if((i&gt;&gt;j)&amp;1) k++;
            k++;
            if(k&lt;=ans) continue;
            mp.clear();
            string now;
            int tmp=0;
            bool flag=true;
            for(int j=0;j&lt;s.size();j++){
                now+=s[j];
                if((i&gt;&gt;j)&amp;1){
                    if(mp.find(now)==mp.end()) mp.insert(now),now.clear(),tmp++;
                    else{
                        flag=false;
                        break;
                    }
                }
            }
            if(!flag) continue;
            if(mp.find(now)==mp.end()) mp.insert(now);
            else continue;
            tmp++;
            ans=max(ans,tmp);
        }
        return ans;
    }
};
</code></pre>
<p><a href="https://leetcode-cn.com/problems/maximum-non-negative-product-in-a-matrix/">5521. 矩阵的最大非负积</a></p>
<p>二维dp，注意边界</p>
<pre><code>class Solution {
public:
    long long dp[20][20][2];
    int maxProductPath(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int mod=(int)1e9+7;
        int n=grid.size();
        int m=grid[0].size();
        dp[0][1][0]=1;
        dp[0][1][1]=1;
        dp[1][0][0]=1;
        dp[1][0][1]=1;
        for(int i=0;i&lt;n;i++){
            for(int j=0;j&lt;m;j++){
                i++,j++;
                if(i!=1 &amp;&amp; j!=1){
                    dp[i][j][0]=max(max(dp[i][j-1][1]*grid[i-1][j-1],dp[i][j-1][0]*grid[i-1][j-1]),max(dp[i-1][j][1]*grid[i-1][j-1],dp[i-1][j][0]*grid[i-1][j-1]));
                dp[i][j][1]=min(min(dp[i][j-1][1]*grid[i-1][j-1],dp[i][j-1][0]*grid[i-1][j-1]),min(dp[i-1][j][1]*grid[i-1][j-1],dp[i-1][j][0]*grid[i-1][j-1]));
                }else if(i==1){
                    dp[i][j][0]=max(dp[i][j-1][1]*grid[i-1][j-1],dp[i][j-1][0]*grid[i-1][j-1]);
                    dp[i][j][1]=min(dp[i][j-1][1]*grid[i-1][j-1],dp[i][j-1][0]*grid[i-1][j-1]);
                }else{
                    dp[i][j][0]=max(dp[i-1][j][1]*grid[i-1][j-1],dp[i-1][j][0]*grid[i-1][j-1]);
                    dp[i][j][1]=min(dp[i-1][j][1]*grid[i-1][j-1],dp[i-1][j][0]*grid[i-1][j-1]);
                }
                
                i--,j--;
            }
        }
        return dp[n][m][0]&lt;0?-1:(dp[n][m][0]%mod);
    }
};
</code></pre>
<p><a href="https://leetcode-cn.com/problems/minimum-cost-to-connect-two-groups-of-points/">5522. 连通两组点的最小成本</a></p>
<p>参考<a href="https://cp-wiki.vercel.app/tutorial/leetcode/WC207/#problem-d-%E8%BF%9E%E9%80%9A%E4%B8%A4%E7%BB%84%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E6%88%90%E6%9C%AC">lucifer1004的题解</a></p>
<pre><code>const int INF = 0x3f3f3f3f;

class Solution {
public:
    int connectTwoGroups(vector&lt;vector&lt;int&gt;&gt;&amp; cost) {
        int n = cost.size(), m = cost[0].size();
        vector&lt;int&gt; dp(1 &lt;&lt; m, INF);
        dp[0] = 0;
        for (int i = 0; i &lt; n; ++i) {
            vector&lt;int&gt; ndp(1 &lt;&lt; m, INF);
            for (int last = 0; last &lt; (1 &lt;&lt; m); ++last) {
                if (dp[last] == INF)
                    continue;
                for (int j = 0; j &lt; m; ++j) {
                    int nxt = last | (1 &lt;&lt; j);
                    ndp[nxt] = min(ndp[nxt], dp[last] + cost[i][j]);
                }
                int v = (1 &lt;&lt; m) - 1 - last;
                if (v &gt; 0) {
                    for (int j = v; j &gt; 0; j = v &amp; (j - 1)) {
                        int c = 0;
                        for (int k = 0; k &lt; m; ++k)
                            if (j &amp; (1 &lt;&lt; k))
                                c += cost[i][k];
                        int nxt = last | j;
                        ndp[nxt] = min(ndp[nxt], dp[last] + c);
                    }
                }
            }
            dp = move(ndp);
        }
        return dp.back();
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[LeetCode每日刷题]2020.09.20]]></title>
        <id>https://938650141.github.io/post/leetcode-mei-ri-shua-ti-20200920/</id>
        <link href="https://938650141.github.io/post/leetcode-mei-ri-shua-ti-20200920/">
        </link>
        <updated>2020-09-20T00:46:21.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<ol start="78">
<li>子集<br>
给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</li>
</ol>
</blockquote>
<p>直接循环0~2^n-1，根据位运算得子集放入答案数组中</p>
<pre><code>class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) {
        vector&lt;vector&lt;int&gt;&gt;ans;
        int n=nums.size();
        for(int i=0;i&lt;(1&lt;&lt;n);i++){
            vector&lt;int&gt;v;
            for(int j=0;j&lt;n;j++){
                if((i&gt;&gt;j)&amp;1) v.push_back(nums[j]);
            }
            ans.push_back(v);
        }
        return ans;
    }
};
</code></pre>
<blockquote>
<ol start="112">
<li>路径总和<br>
给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</li>
</ol>
</blockquote>
<p>递归到子节点记录路径和是否等于目标和，如果是将flag标记为true<br>
最后返回flag即可</p>
<pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool flag;
    void dfs(TreeNode* o,int sum,int now){
        now+=o-&gt;val;
        if(o-&gt;left==nullptr &amp;&amp; o-&gt;right==nullptr) flag|=(now==sum);
        else{
            if(o-&gt;left!=nullptr) dfs(o-&gt;left,sum,now);
            if(o-&gt;right!=nullptr) dfs(o-&gt;right,sum,now);
        }
    }
    bool hasPathSum(TreeNode* root, int sum) {
        if(root==nullptr) return false;
        dfs(root,sum,0);
        return flag;
    }
};
</code></pre>
<blockquote>
<ol start="113">
<li>路径总和 II<br>
给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</li>
</ol>
</blockquote>
<p>上题一样的思路，只不过多维护一个路径数组，标记flag变成数组放入答案中。</p>
<pre><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; ans;
    void dfs(TreeNode* o,int sum,vector&lt;int&gt;now,int tmp){
        now.push_back(o-&gt;val);
        tmp+=o-&gt;val;
        if(o-&gt;left==nullptr &amp;&amp; o-&gt;right==nullptr &amp;&amp; tmp==sum){
            ans.push_back(now);
        }else{
            if(o-&gt;left!=nullptr) dfs(o-&gt;left,sum,now,tmp);
            if(o-&gt;right!=nullptr) dfs(o-&gt;right,sum,now,tmp);
        }
    }
    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) {
        if(root==nullptr) return ans;
        dfs(root,sum,{},0);
        return ans;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[LeetCode双周赛]第35场双周赛]]></title>
        <id>https://938650141.github.io/post/leetcode-shuang-zhou-sai-di-35-chang-shuang-zhou-sai/</id>
        <link href="https://938650141.github.io/post/leetcode-shuang-zhou-sai-di-35-chang-shuang-zhou-sai/">
        </link>
        <updated>2020-09-20T00:21:09.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<ol start="5503">
<li>所有奇数长度子数组的和<br>
给你一个正整数数组 arr ，请你计算所有可能的奇数长度子数组的和。<br>
子数组 定义为原数组中的一个连续子序列。<br>
请你返回 arr 中 所有奇数长度子数组的和 。</li>
</ol>
</blockquote>
<p>只需循环左端点的基础上循环右端点并维护左端点为起点右端点为重点的区间和，判断区间长度为奇书则加入到答案中。</p>
<pre><code>class Solution {
public:
    int sumOddLengthSubarrays(vector&lt;int&gt;&amp; arr) {
        int ans=0;
        for(int i=0;i&lt;arr.size();i++){
            int sum=0;
            for(int j=i;j&lt;arr.size();j++){
                sum+=arr[j];
                if((j-i)%2==0) ans+=sum;
            }
        }
        return ans;
    }
};
</code></pre>
<blockquote>
<ol start="5505">
<li>所有排列中的最大和<br>
有一个整数数组 nums ，和一个查询数组 requests ，其中 requests[i] = [start<sub>i</sub>, end<sub>i</sub>] 。第 i 个查询求 nums[start<sub>i</sub>] + nums[start<sub>i</sub> + 1] + ... + nums[end<sub>i</sub> - 1] + nums[end<sub>i</sub>] 的结果 ，start<sub>i</sub> 和 end<sub>i</sub> 数组索引都是 从 0 开始 的。<br>
你可以任意排列 nums 中的数字，请你返回所有查询结果之和的最大值。<br>
由于答案可能会很大，请你将它对 109 + 7 取余 后返回。</li>
</ol>
</blockquote>
<p>实际上是每次选取多个nums里的某个区间进行求和，如果从单个元素的贡献来看，如果某个位置被覆盖的次数最多，如果想要答案最大，则这个元素是nums里最大的数字。根据这个思路只需要统计每个位置被覆盖的次数，然后排序被统计的次数，再排序nums，这两者相同位置相乘求和即可。</p>
<pre><code>class Solution {
public:
    long long a[100005];
    int maxSumRangeQuery(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; requests) {
        long long ans=0;
        int mod=(int)1e9+7;
        for(int i=0;i&lt;requests.size();i++) a[requests[i][0]+1]++,a[requests[i][1]+2]--;
        int n=nums.size();
        for(int i=1;i&lt;=n;i++) a[i]+=a[i-1];
        vector&lt;long long&gt;v;
        sort(nums.begin(),nums.end());
        for(int i=1;i&lt;=n;i++) v.push_back(a[i]);
        sort(v.begin(),v.end());
        for(int i=0;i&lt;n;i++) ans=(ans+v[i]*(nums[i]))%mod;
        return ans;
    }
};
</code></pre>
<blockquote>
<ol start="5504">
<li>使数组和能被 P 整除<br>
给你一个正整数数组 nums，请你移除 最短 子数组（可以为 空），使得剩余元素的 和 能被 p 整除。 不允许 将整个数组都移除。<br>
请你返回你需要移除的最短子数组，如果无法满足题目要求，返回 -1 。<br>
子数组 定义为原数组中连续的一组元素。</li>
</ol>
</blockquote>
<p>如果要让数组和能被P整除，反过来就是找一段子区间的和是(数组和%p)</p>
<pre><code>class Solution {
public:
    unordered_map&lt;int,int&gt;mp;
    long long sum[100005];
    int minSubarray(vector&lt;int&gt;&amp; nums, int p) {
        long long a=0;
        for(int i=0;i&lt;nums.size();i++) sum[i+1]=nums[i],a+=nums[i];
        a%=p;
        if(a==0) return 0;
        int n=nums.size();
        int ans=0x3f3f3f3f;
        mp[0]=0;
        for(int i=1;i&lt;=n;i++){
            sum[i]+=sum[i-1];
            sum[i]%=p;
            if(mp.find((sum[i]-a+p)%p)!=mp.end()){
                ans=min(ans,i-mp[(sum[i]-a+p)%p]);
            }
            mp[sum[i]]=i;
        }
        return ((ans==0x3f3f3f3f)||(ans==n))?-1:ans;
    }
};
</code></pre>
<blockquote>
<ol start="5506">
<li>奇怪的打印机 II<br>
给你一个奇怪的打印机，它有如下两个特殊的打印规则：<br>
每一次操作时，打印机会用同一种颜色打印一个矩形的形状，每次打印会覆盖矩形对应格子里原本的颜色。<br>
一旦矩形根据上面的规则使用了一种颜色，那么 相同的颜色不能再被使用 。<br>
给你一个初始没有颜色的 m x n 的矩形 targetGrid ，其中 targetGrid[row][col] 是位置 (row, col) 的颜色。<br>
如果你能按照上述规则打印出矩形 targetGrid ，请你返回 true ，否则返回 false 。</li>
</ol>
</blockquote>
<p>我的想法是每次找到一个矩形，然后将其全部变成通用颜色，直到找不到为止，如果最后全部方块都是通用颜色则说明true否则false。</p>
<pre><code>class Solution {
public:
    int mnh[100],mxh[100],mnl[100],mxl[100];
    int pic[105][105];
    int vis[105];
    bool isPrintable(vector&lt;vector&lt;int&gt;&gt;&amp; targetGrid) {
        for(int i=1;i&lt;=60;i++) mnh[i]=0x3f3f3f3f,mnl[i]=0x3f3f3f3f;
        for(int i=1;i&lt;=60;i++) mxh[i]=0xcfcfcfcf,mxl[i]=0xcfcfcfcf;
        for(int i=0;i&lt;targetGrid.size();i++){
            for(int j=0;j&lt;targetGrid[i].size();j++){
                int now=targetGrid[i][j];
                mnh[now]=min(mnh[now],i+1);
                mxh[now]=max(mxh[now],i+1);
                mnl[now]=min(mnl[now],j+1);
                mxl[now]=max(mxl[now],j+1);
                pic[i+1][j+1]=targetGrid[i][j];
            }
        }
        bool flag=true;
        while(flag){
            flag=false;
            for(int i=1;i&lt;=60;i++){
                bool isSq=true;
                if(mxh[i]-mnh[i]&lt;0 || mxl[i]-mnl[i]&lt;0) isSq=false;
                for(int j=mnh[i];j&lt;=mxh[i];j++){
                    for(int k=mnl[i];k&lt;=mxl[i];k++){
                        if(pic[j][k]!=i &amp;&amp; pic[j][k]!=100 ) isSq=false;
                    }
                }
                if(isSq){
                    flag=true;
                    for(int j=mnh[i];j&lt;=mxh[i];j++){
                        for(int k=mnl[i];k&lt;=mxl[i];k++){
                            pic[j][k]=100;
                        }
                    }
                    mnh[i]=0x3f3f3f3f,mnl[i]=0x3f3f3f3f;
                    mxh[i]=0xcfcfcfcf,mxl[i]=0xcfcfcfcf;
                }
            }
        }
        int n=(int)targetGrid.size();
        int m=(int)targetGrid[0].size();
        bool ok=true;
        for(int i=1;i&lt;=n;i++)
            for(int j=1;j&lt;=m;j++)
                if(pic[i][j]!=100) ok=false;
        return ok;
    }
};
</code></pre>
]]></content>
    </entry>
</feed>